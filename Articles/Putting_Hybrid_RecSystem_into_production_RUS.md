# Создание работающей рекомендательной системы
date: 220118 0928


Оригинальная публикация [Putting Hybrid Recomendation System into production](https://anchormen.nl/blog/data-science-ai/putting-a-hybrid-recommendation-system-into-production/)


В Интернете не так много примеров кода рекомендательных систем, и еще меньше рассказов о том, как внедрить гибридную (коллаборативную фильтрацию и контентную) систему рекомендаций в производство. Эта публикация направлена на заполнение данного пробела. В этом примере мы будем использовать LightFM — быструю и масштабируемую реализацию алгоритмов гибридных рекомендаций Python и набор данных MovieLens. [Вы можете найти полный код на GitHub здесь.](https://github.com/Anchormen/hybridrecommendationsystem)

Мы предполагаем, что вы знакомы с рекомендательными системами, коллаборативной фильтрацией, фильтрацией на основе контента и гибридными методами, основанными на матричной факторизации. Итак, приступим!

При внедрении рекомендательной системы в производство возникает множество проблем. Вот некоторые из наиболее частых проблем, которые вам, возможно, придется решить в вашей системе рекомендаций:

- Как делать рекомендации в режиме реального времени
- Быстрое включение новых взаимодействий в модель
- Прогнозирование для новых пользователей/элементов
- Измерения за пределами точности, например, насколько неожиданны рекомендации
- Предвзятость популярности
- Предвзятость рейтинга
- Самоисполняющееся пророчество
- Устойчивость к мошенничеству

В этой статье мы сосредоточимся на первых трех задачах (решение которых позволит вам предлагать «быстрые» рекомендации пользователям) — как давать рекомендации в режиме реального времени, как быстро внедрять новые взаимодействия и как прогнозировать для новых пользователей/элементов. Кроме того, мы также представим пример, иллюстрирующий это, с использованием пакета LightFM.

### Как делать рекомендации в реальном времени

Вы можете получить рекомендации в режиме реального времени, правильно спроектировав архитектуру для своей проблемы. У вас есть два варианта:

1. После обновления рекомендательной модели создайте оценки для всех пар «пользователь-элемент» и сохраните их в базе данных и эту базу данных разместите на внешнем сервере.
2. Разместите рекомендательную модель на сервере и предоставляйте рекомендации по запросу для пар «пользователь-элемент» в то время, когда это необходимо, через API.

Первый вариант имеет смысл, если у вас небольшой или средний объем данных по следующим причинам:
- Генерация оценок для всех пар «пользователь-элемент» будет относительно быстрой.
- Вычислительные ресурсы используются только при обучении и пакетном прогнозировании для пользователей, после чего виртуальную машину можно отключить. Вам не нужно держать машину в рабочем состоянии, чтобы получать запросы в любое время
- Это проще, потому что достаточно запустить пакетное прогнозирование как задание, и вам не нужно разбираться с API и сложностями обновления модели без ее отключения.

Второй вариант имеет смысл, если у вас большой объем данных, потому что:
- Неэффективно или невозможно генерировать оценки для всех пар «пользователь-элемент».


### Данные

В дальнейшем мы будем использовать набор данных MovieLens, чтобы проиллюстрировать, как создать гибридную рекомендательную систему с использованием LightFM. Эта версия набора данных взята з Kaggle и включает в себя признаки пользователей и фильмов, а также явные рейтинги для фильмов от 1 до 5. Однако LightFM предназначен для неявных данных обратной связи (когда отсутствие рекомендации рассматривается как отрицательная рекомендация) Итак, мы будем рассматривать рейтинги как неявную обратную связь. Это означает, что если пользователь оценил фильм, это считается положительным отзывом, если нет, то отрицательным. Мы делаем еще один трюк: если пользователь поставил фильму оценку ниже 3 звезд, мы также рассматриваем это как негативный отзыв, потому что знаем, что фильм пользователю не понравился.

Вопрос по использованию новых признаков послужил для меня причиной поиска и перевода этой статьи.  Для набора данных пользователей сохранена следующая информация - возраст, пол, род занятий и почтовый индекс зрителя.  Для фильмов кроме названия и даты выхода также сохранена градация на жанры - "экшн", "комедия", "триллер" и так далее. Причем для один и тот же фильм может относиться сразу к нескольким жанрам. Модель LightFM понимает либо бинарные, либо непрерывные признаки.  Для дальнейшего использования часть полей была отброшена, а другая часть была двоично закодирована (one-hot encoding).

Набор данных (специально) разделен на две части. «Текущие» взаимодействия, представляющие данные, доступные при обучении полной модели, и «новые» взаимодействия, представляющие те, которые произошли после обучения, но мы все еще хотим рассмотреть рекомендации. Разделение выполняется с использованием порога времени взаимодействия. В результате в «новом» наборе данных будут совершенно новые пользователи, которых не было в «текущем» наборе, а также будет новое взаимодействие со старыми пользователями. Одной из проблем рекомендательных систем является включение совершенно новых пользователей без необходимости повторного обучения всей модели целиком.

![user interactions](https://anchormen.nl/wp-content/uploads/2021/04/user-interactions-new.png)  
_Рисунок 1. Взаимодействие пользователей во времени. Пользователи упорядочиваются по их первому взаимодействию. Каждая точка представляет собой взаимодействие, а красная линия представляет собой «текущее», «новое» разделение_

Затем «текущий» набор разбивается на набор для обучения и проверки. В этом посте мы представляем основные моменты кода.
```python
interactions_current, interactions_new = current_new_split(interactions, 0.9)
interactions_current_train, interactions_current_val = train_test_split_randomly(interactions_current, 0.3)
```


### Подготовка Набора данных 

Пакет LightFM понимает данные в определенных матричных форматах.  Для подготовки можно использовать процедуры из встроенного в пакет класса **Dataset**. 
```python
user_ids_buffered = range(1000)
item_ids_buffered = range(1700)

user_feature_names = user_features.columns.tolist()
user_feature_names.remove("user_id")

item_feature_names = item_features.columns.tolist()
item_feature_names.remove("movie_id")

dataset = Dataset()
dataset.fit(
    users=user_ids_buffered,
    items=item_ids_buffered,
    user_features=user_feature_names,
    item_features=item_feature_names
)
```
Настало время для использования первого тюка.  Несмотря на то, что в обучающих данных всего 943 пользователя и 1682 фильма, мы инициализируем набор данных большим количеством пользователей/элементов (1000 и 1700 соответственно), чтобы освободить место для новых пользователей/элементов. Причина в том, что после обучения модели LightFM новые пользователи/элементы не могут быть добавлены до тех пор, пока вся модель не будет переобучена. Следовательно, во время обучения полной модели мы ожидаем, что некоторые новые пользователи/элементы присоединятся, и мы добавляем фиктивных пользователей/элементов в обучающий набор. Эти фиктивные пользователи/элементы пусты, у них нет никаких взаимодействий или функций, но они следят за тем, чтобы матрицы в модели имели правильный размер.

Затем мы строим матрицы взаимодействия и функций, используя класс _**Dataset**_ и некоторые вспомогательные функции, которые преобразуют фреймы данных в ожидаемые форматы _**build_interactions**_ и **_build_user_features_, _build_item_features_**.
```python
interaction_matrix_current, _ = dataset.build_interactions(
    transform_interactions(interactions_current))
interaction_matrix_current_train, _ = dataset.build_interactions(
    transform_interactions(interactions_current_train))
interaction_matrix_current_val, _ = dataset.build_interactions(
    transform_interactions(interactions_current_val))

user_features_matrix_current = dataset.build_user_features(
    transform_features(user_features_current, "user_id"))
item_features_matrix_current = dataset.build_item_features(
    transform_features(item_features_current, "movie_id"))
```

### Обучение модели
После подготовки специальных наборов данных настало время подбора гиперпараметров.  Основных гиперпараметров два - размерность семантического вектора внутреннего представления и количество эпох.  По умолчанию количество компонент в семантическом векторе равно 10.  В статье автор подбирает только один гиперпараметр - количество эпох.   Для подбора гиперпараметров предварительно был выделен тестовый набор данных в размере 30% путем случайного отбора.  
```python
model = LightFM(loss="warp")
evaluator = Evaluator()
for epochs in [100, 200, 300, 500, 1000, 2000]:
    print(f"Epochs: {epochs}")
    
    model.fit(
        interaction_matrix_current_train,
        epochs=epochs,
        user_features=user_features_matrix_current,
        item_features=item_features_matrix_current
    )
    
    evaluator.evaluate(
        epochs, model,
        interaction_matrix_current_train, interaction_matrix_current_val,
        user_features_matrix_current, item_features_matrix_current)
```
Наилучший вариант был достигнут по итогам 2000 эпох обучения с результатом AUCROC score 0.9216 на тестовом наборе данных. 
```python
best_epochs = evaluator.get_best_epochs()
model.fit(
    interaction_matrix_current,
    epochs=best_epochs,
    user_features=user_features_matrix_current,
    item_features=item_features_matrix_current
)
```
В нашем воображаемом сценарии мы теперь можем размещать эту модель в production. 


 ### Как быстро включить новые взаимодействия в модель

В идеальной ситуации система рекомендаций немедленно включала бы в модель каждое новое взаимодействие (выставление зрителем оценки фильму). Это означает, что когда пользователь просматривает веб-сайт и делает следующий клик, рекомендации уже учитывают все предыдущие клики. Поскольку в гибридной системе рекомендаций есть компонент совместной фильтрации, для каждого нового взаимодействия нам потребуется переобучать всю модель. Однако в LightFM есть метод **fit_partial** для обучения только части модели с использованием только новых взаимодействий. Эта функция позволяет быстро включать в модель новые взаимодействия, но потенциально за счет снижения стабильности модели.

Следовательно, хорошим подходом будет следующий:
- Используйте **fit_partial** для частого включения новых взаимодействий в модель.
- Время от времени переучивать всю модель с нуля

Давайте посмотрим, как работает **fit_partial**. Опять же, мы можем использовать перекрестную проверку, чтобы решить, сколько эпох мы должны обучать. Однако количество новых взаимодействий может быть небольшим, поэтому хорошей идеей будет несколько раз провести разделение на обучение и валидацию и усреднить показатели производительности. Вычисление метрик и усреднение нескольких разделений на обучение и валидацию реализовано во вспомогательном классе **Evaluator**, вы можете увидеть его в блокноте. Обратите внимание, что каждый раз, когда мы запускаем тест, мы делаем копию исходной модели и запускаем **fit_partial** на копии.
```python
evaluator = Evaluator()
for epochs in [100, 500, 1000, 2000]:
    print(f"Epochs: {epochs}")

    num_fold = 5
    for fold in range(num_fold):
        print(f"fold: {fold}")
              
        interactions_new_train, interactions_new_val = train_test_split_randomly(interactions_new, 1/num_fold)
        interaction_matrix_new_train, _ = dataset.build_interactions(
            transform_interactions(interactions_new_train))
        interaction_matrix_new_val, _ = dataset.build_interactions(
            transform_interactions(interactions_new_val))
        
        model_fold = deepcopy(model)
        model_fold.fit_partial(
            interaction_matrix_new_train,
            user_features=user_features_matrix_new,
            item_features=item_features_matrix_new,
            epochs=epochs
        )

        evaluator.evaluate(
            epochs, model_fold,
            interaction_matrix_new_train, interaction_matrix_new_val,
            user_features_matrix_new, item_features_matrix_new)
```
Как только мы нашли лучшее количество эпох, мы можем вызвать **fit_partial** на полном наборе взаимодействий.  В данном случае количество эпох для дообучения снизилось до 1000. 
```python
best_epochs = evaluator.get_best_epochs()
model.fit_partial(
    interaction_matrix_new,
    user_features=user_features_matrix_new,
    item_features=item_features_matrix_new,
    epochs=best_epochs
)
```
_**fit_partial**_ смог включать в модель совершенно новых пользователей, которых не было при обучении полной модели, потому своевременно на этапе определения размерности мы включили в набор данных несколько дополнительных фиктивных пользователей.

Теперь давайте посмотрим на пример этих новых пользователей, только что включенных в модель. Этот пользователь оценил следующие фильмы (на 3 звезды и выше):
```
Dead Man Walking (1995), [‘Drama’]
People vs. Larry Flynt, The (1996), [‘Drama’]
Fargo (1996), [‘Crime’, ‘Drama’, ‘Thriller’]
Ransom (1996), [‘Drama’, ‘Thriller’]
Independence Day (ID4) (1996), [‘Action’, ‘Sci-Fi’, ‘War’]
Star Wars (1977), [‘Action’, ‘Adventure’, ‘Romance’, ‘Sci-Fi’, ‘War’]
Scream (1996), [‘Horror’, ‘Thriller’]
English Patient, The (1996), [‘Drama’, ‘Romance’, ‘War’]
Chasing Amy (1997), [‘Drama’, ‘Romance’]
Mary Reilly (1996), [‘Drama’, ‘Thriller’]
Twister (1996), [‘Action’, ‘Adventure’, ‘Thriller’]
Face/Off (1997), [‘Action’, ‘Sci-Fi’, ‘Thriller’]
Breakdown (1997), [‘Action’, ‘Thriller’]
River Wild, The (1994), [‘Action’, ‘Thriller’]
Ghost and the Darkness, The (1996), [‘Action’, ‘Adventure’]
Boot, Das (1981), [‘Action’, ‘Drama’, ‘War’]
Unforgettable (1996), [‘Sci-Fi’, ‘Thriller’]
Smilla’s Sense of Snow (1997), [‘Action’, ‘Drama’, ‘Thriller’]
Trees Lounge (1996), [‘Drama’]
Frighteners, The (1996), [‘Comedy’, ‘Horror’]
```
А вот наши рекомендации для этого пользователя, исключающие те фильмы, что он уже оценил. 
```
Twelve Monkeys (1995), [‘Drama’, ‘Sci-Fi’]
Contact (1997), [‘Drama’, ‘Sci-Fi’]
Time to Kill, A (1996), [‘Drama’]
Leaving Las Vegas (1995), [‘Drama’, ‘Romance’]
Jerry Maguire (1996), [‘Drama’, ‘Romance’]
Star Trek: First Contact (1996), [‘Action’, ‘Adventure’, ‘Sci-Fi’]
Trainspotting (1996), [‘Drama’]
Titanic (1997), [‘Action’, ‘Drama’, ‘Romance’]
U.S. Marshalls (1998), [‘Action’, ‘Thriller’]
Air Force One (1997), [‘Action’, ‘Thriller’]
Lost Highway (1997), [‘Mystery’]
Rock, The (1996), [‘Action’, ‘Adventure’, ‘Thriller’]
Screamers (1995), [‘Sci-Fi’]
Mission: Impossible (1996), [‘Action’, ‘Adventure’, ‘Mystery’]
Men in Black (1997), [‘Action’, ‘Adventure’, ‘Comedy’, ‘Sci-Fi’]
Courage Under Fire (1996), [‘Drama’, ‘War’]
Absolute Power (1997), [‘Mystery’, ‘Thriller’]
Primal Fear (1996), [‘Drama’, ‘Thriller’]
Juror, The (1996), [‘Drama’, ‘Thriller’]
Godfather, The (1972), [‘Action’, ‘Crime’, ‘Drama’]
```
Из этого мы видим, что этого пользователя в основном интересует драма, приправленная некоторой научной фантастикой, триллером и мелодрамой, но точно не комедия. Мы видим это в рекомендованных фильмах, поэтому можем предположить, что модель работает правильно.

### Резюме

В этой статье мы узнали о двух архитектурах, позволяющих давать рекомендации в реальном времени, и о том, когда их использовать. Мы использовали набор данных MovieLens для обучения модели LightFM. Мы научились быстро включать новые взаимодействия в модель без ее полного переобучения, используя функцию _**fit_partial**_. Наконец, мы показали, как подготовить модель к ожидаемому появлению новых пользователей/элементов, дополнив обучающие данные некоторыми фиктивными пользователями/элементами.
